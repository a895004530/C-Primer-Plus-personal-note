# 类继承

派生类对象存储了基类的数据成员（派生类继承了基类的实现）

派生类对象存储了基类的方法（派生类继承了基类的接口）

需要在继承特性中添加：

- 派生类需要自己的构造函数
- 派生类可以根据需要添加额外的数据成员和成员函数

#### 访问权限

派生类不能直接访问基类的私有成员，而必须提供过基类的方法进行访问。

创建派生类对象时，程序首先创建基类对象。

```c++
RetedPlayer::RatedPlayer(unsigned int r,const string & fn,const string &ln,bool ht): TableTennisPlayer(fn,ln,ht)
{
	rating = r;
}
```

其中TableTennisPlayer(fn,ln,ht)是成员初始化列表，调用了TableTennisPlayer的构造函数。

假设程序包含以下声明：

```c++
RatedPlayer rplayer1(1140,"aaa","bbb",true);
```

程序将先把（"aaa","bbb",true）传递给TableTennisPlayer的构造函数，然后程序再完成对RatedPlayer对象的创建。

注意：如果不调用基类构造函数，那么程序将自动使用默认的基类构造函数，即：

```c++
RetedPlayer::RatedPlayer(unsigned int r,const string & fn,const string &ln,bool ht): 
{
	rating = r;
}
//等价于
RetedPlayer::RatedPlayer(unsigned int r,const string & fn,const string &ln,bool ht): TableTennisPlayer()
{
	rating = r;
}
```



#### 有关派生构造函数的要点：

- 首先要创建基类对象；
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
- 派生类构造函数应初始化派生类新增的数据成员。

#### 派生类和基类之间的特殊关系：

派生类对象可以使用基类的方法，条件是方法不是私有的。

```c++
RatedPlayer rplayer(111,"aaa","bb",true);
rplayer.Name();
```

基类指针可以在不进行显示类型转换的情况下指向派生类对象

基类引用可以在不进行显示类型转换的情况下引用派生类对象

```c++
TableTennisPlayer * pt = &rplayer;
TableTennisPlayer & rt = rplayer;
```

然而，基类指针或引用**只能**调用基类方法。即rt 或 pt不能来调用RatedPlayer的方法。

注意，这种方法是单向的，即不可以将基类对象和地址赋给派生类引用和指针。

```c++
TableTennisPlayer player("aaa","bbb",true);
RatedPlayer & rr = player;
RatedPlayer * pr = player;
```

理解：派生类是基于基类的，因此派生类对象可以使用基类的方法，而基类不能使用派生的（因为派生类本身就是基类，只不过多了私有成员和方法）

#### 继承：is-a 关系

C++有三种继承方式：公有继承、保护继承、私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生对象也是一个基类对象，可以对基类对象进行的任何操作也可以对派生对象执行。

#### 多态公有继承

若希望一个方法在派生类和基类中的行为是不通融的，换句话说，方法的行为应取决于调用该方法的对象，这种较复杂的行为称为多态，即具有多种形态。有两种重要的机制可以用于实现多态：

- 派生类中重新定义基类的方法。
- 使用虚方法。

虚方法：使用virtual关键字，，如果方法是通过引用类型或指针类型而不是对象调用的，它将确定使用哪一种方法（基类还是派生）。如果没有使用virtual，程序将根据引用类型或者指针类型而选择方法；如果使用了virtual，则会通过引用或者指针所指向的对象的类型来决定方法。

```c++
Brass dom("aaa",111,21212);
BrassPlus dot("bbb",222,3333);
Brass & b1_ref = dom;
Brass & b2_ref = dot;//这里b2_ref引用的是dot但自身类型是Brass
b1_ref.ViewAcct();//Brass::ViewAcct();
b2_ref.ViewAcct();//ViewAcct()是虚方法，那么这里将会使用BrassPlus::ViewAcct()
//否则Brass::ViewAcct();
```

注意：如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样程序将根据对象而不是引用或者指针来选择方法版本。为基类声明一个**虚析构函数**也是一种管理（这样做是为了确保释放派生对象时，按正确顺序调用析构函数，后面有介绍）



书中代码有关输出模式的设置代码：

设置模式后，输出的模式将保持不变，因此该方法格式模式重置为调用前的状态。为了避免代码重复，将设置格式的代码放在函数中，需要设置的时候调用即可，避免了代码的重复

```c++
//formatting stuff
typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f,precis p);

format setFormat()//保存设置
{
	return cout.setf(strd::ios_base::fixed,std::ios_base::floatfield);
}

void restore(format f, precis p )//恢复
{
    cout.setf(f,std::ios_base::floatfield);
    cout.precision(p);
}
```

多态性是由如下代码提供的。

```c++
for (i=0;i<CLIENTS;i++)
{
	p_clients[i]->ViewAcct();
	cout<<endl;
}
```

其中ViewAcct是被声明为虚的，因此会根据所指的成员类型选择ViewAcct()



#### 静态联编和动态联编

将源代码中的函数调用解释为执行特定函数代码块被称作函数名联编（binding）。C++可以在编译过程中完成这种联编，在编译过程中进行联编被称为静态联编。然而虚函数使得这项工作变得更加困呐，因为编译器不知道用户将选择哪个类型的对象，所以编译器必须生成嫩能够在程序运行时选择正确的虚方法的代码，这被称作动态联编。

##### 指针和引用类型的兼容性

一般情况下，C++不允许将一种类型的地址赋给另一种类型的指针

```c++
doubel x=2.5;
int *pi = &x;//错误
long &rl = x;//错误
```

然而，有例外：指向基类的引用或指针可以引用派生类对象且不必进行显式强制转换

```c++
BrassPlus d("aaa",1111,2222);
Brass * pd = &d;
Brass & rd = d;
```

将派生类引用或指针转换为基类引用或指针被称为：向上强制转换。可以理解为派生类都是基类的对象，因为它继承了所有基类的成员，所以可以对派生类使用所有的基类方法。因此，向上强制转换不会造成任何的问题，并且这种向上转换是可以传递的，即子类的子类也可以以基类的引用或指针来引用。

**注意：**相反情况下，向下强制转换是不被允许的，因为子类中添加的成员，基类不一定有，这时候有可能造成错误。



##### 虚成员函数和动态联编

```c++
BrassPlus bp;
Brass * rb;
rb= & bp;
rb ->ViewAcct();
```

如果ViewAcct()没有被声明为虚的，则rb->ViewAcct()会根据指针类型（即rb的类型Brass）调用Brass::ViewAcct()；若声明了虚成员函数，则会调用BrassPlus::ViewAcct()。



##### 为什么要有两种类型的联编？都用动态的不好吗？

在解释这个问题前，我们先了解C++是怎么做到动态联编的。即：虚函数的工作原理

通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向**函数地址数组**的指针，这个数组称为虚函数表。虚函数表中储存了为类对象进行声明的虚函数的地址。

例如：基类对象包含一个指针，该指针指向基类中所有的虚函数的地址表。派生类对象也包含一个独立的地址表指针。如果派生类提供了虚函数的新定义，那么该虚函数表将会保存新函数的地址，如果没有提供新的定义，那么虚函数表将保存继承下来的函数地址。同理，如果派生类定义了一个新的虚函数（基类中没有），那么新的虚函数也会被添加到虚函数表中。

这也意味着，使用虚函数时，在内存和执行速度方面有一定的成本：

- 每个对象都将增大，增大量为存储地址的空间。
- 对于每个类（基类与子类）都将创建一个虚函数地址表（数组），然后保存一个隐藏成员（指针）于对象中。
- 对每个虚函数的调用，都要执行一项额外的操作，即从虚函数表中查找对应函数的地址，然后再调用对应函数。

这也是为什么C++没有摒弃静态联编。

##### 虚函数注意事项：

几个要点：

- virtual关键字
- 用指针或者引用来调用虚函数，程序将根据对象类型而不是指针的类型选择方法。这称为动态联编。
- 如果定义的类将被用作基类，则应将那些要在**派生类中重新定义**的类方法声明为虚的。



1. 构造函数不能是虚函数，因为创建派生类对象时，将调用派生类的构造函数，然后在这个构造函数中将使用基类的一个构造函数，因此派生类不继承基类的构造函数，将构造函数设置为虚函数没有意义。

2. 析构函数应当是虚函数，除非类不用做基类。例如:

   ```c++
   Brass * pb = new BrassPlus;
   ...
   delete pb;
   ```

   如果没有定义虚析构函数，那这里会默认调用~Brass()，这将会释放BrassPlus对象中的Brass的组成部分，而不会释放新的类成员所占用的内存。但如果使用了虚方法，则上述代码将会先调用~BrassPlus()，再调用~Brass()。

   这给我们一个经验：即使基类不需要显式析构函数，也应提供虚析构函数，即使它不包含任何操作：

   ```c++
   virtual ~BrassPlus();{ }
   ```

3. 友元

   友元不能是虚函数，因为虚函数是对于类成员来说的，而友元不是类成员。

4. 没有重新定义

   如果派生类没有重新定义，那么它将使用该函数的基类版本。如果派生类处于派生类中（子类的子类的子类...）则将使用最新的虚函数版本。

5. 重新定义将隐藏方法

   ```c++
   class Brass
   {
   	public:
   	virtual void show(int) const;
   	...
   }
   class BrassPlus: public Brass
   {
   	public:
   		virtual void show()const;
   		...
   }
   ```

   新定义的show()不接收任何参数。重新定义不会生成函数的两个重载版本，而是隐藏第一个基类的版本。如果重新定义派生类中的函数，无论参数列表是否相同（比如上面的int 和 void），该操作将隐藏所有的同名基类方法。

   由此引出两个经验规律：

   - 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。（这种特性被称作返回类型协变）（即仅返回值适用，参数不适用）

     ```c++
     class Brass
     {
     	public:
     		virtual Brass & build(int n);//这里返回的是基类引用
     		...
     };
     class BrassPlus: public Brass
     {
     	public:
     		virtual BrassPlus & build(int n);//这里返回的则是派生类引用
     };
     ```

   - 如果基类存在重载函数，且派生类中需要重新定义，则应在派生类中重新定义所有的函数版本。

     ```c++
     class Brass
     {
     	public:
     		virtual Brass & build(int n);
     		virtual Brass & build(double n);
     		virtual Brass & build(long n);//三个版本
     		...
     };
     class BrassPlus: public Brass
     {
     	public:
     		virtual BrassPlus & build(int n);
     		virtual BrassPlus & build(double n);
     		virtual BrassPlus & build(long n);//这里则需要重新定义三个版本
     };
     ```

     如果只要用其中一个版本，即只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法调用它们。

#### 访问控制：protected关键词

关键词protected与private类似，在类外只能用公有类成员来访问。private和protected的区别只有在基类的派生类中才会体现出来。派生类成员可以直接访问基类的保护成员，而不能直接访问基类的private成员。可以理解成protected是处于private和public的一种中间态。

```c++
class Brass
{
	protected:
		double balance;
}
...
...
void BrassPlus::Withdraw(double amt)
{
    ...
    ...
    balance-=amt;//可以直接访问而不需要利用公共方法
}
```

但是，在类设计的时候就需要考虑，因为在这之前我们把Brass类设计成只能通过Deposit（）和Withdraw（）才能修改balance，但对于Brass Plus（），我们可能有

```C++
void BrassPlus::Reset(double amt)
{
	balance = amt;
}
```

这里我们忽略了前面对balance的保护而直接修改了它的值。

因此：**最好对类数据成员采用私有访问控制，而不是保护访问控制。同时通过基类方法使得派生类能够访问基类数据。**

对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数（可以理解成派生链中的共有函数，但是对外是无法访问的。



#### 抽象基类

可以将ABC看作是一种必须实施的接口，ABC要求具体派生类覆盖其纯虚函数，即**迫使派生类遵循ABC设置的接口规则**，这样确保了ABC派生的所有组件都至少支持ABC指定的功能。

纯虚函数：声明的结尾处为=0

```c++
class Base
{
	private:
		double x;
		double y;
		...
	public:
		...
		virtual double Area() const = 0;
		...
}
```

在书上P510的例子中，ABC类中包含Brass和BrassPlus类共有的所有方法和数据成员，而那些在两个类中行为不同的方法被声明为虚函数，其中至少有一个是纯虚函数，这样才能使它成为抽象类。



#### 继承和动态内存分配

##### 第一种情况：派生类不适用new

派生类不使用new，也未包含其他一些不常用的、需要特殊处理的设计特性，上述情况下**不需要**为派生类定义显式析构函数、复制构造函数和赋值运算符

**析构函数：**合适

（1）如果派生类没有定义析构函数，编译器将定义一个不执行任何操作的默认析构函数。

（2）实际上，派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数（派生析构函数执行后再执行基类析构函数）。

（3）假设派生类成员**不需执行任何特殊操作**，所以默认析构函数是合适的。

**复制构造函数：**合适

（1）默认复制构造函数执行成员复制，这对于动态内存分配来说是不合适的，但对于派生类（LacksDMA）成员来说是合适的，因为派生类成员不涉及new与delete动态内存分配。

（2）此示例只需要考虑继承的基类对象。

（3）成员复制是根据数据类型采用相应的复制方式，因此将long复制到long中是通过使用常规赋值完成的，但复制类成员或继承的类组件时，则是使用该类的**复制构造函数**完成的。

（4）派生类的默认复制构造函数使用显式基类复制构造函数来复制派生类对象中的基类部分。

（5）默认复制构造函数对于派生类成员来说是合适的，同时对于继承的基类对象来说也是合适的。

**赋值运算符：**合适

​		与复制构造函数类似，类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。



##### 第二种情况：派生类使用new

在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

**析构函数：**

​		派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类的新成员进行清理。因此使用new的情况下必须通过delete对其进行内存的释放。

**复制构造函数和赋值运算符：**

总之当基类和派生类都采用动态内存分布时，都必须使用相应的基类方法来处理基类元素，对于复制构造函数来说，通过**成员初始化列表调用**基类的复制构造函数；对于赋值运算符，这是通过使用作用域解析运算符显式的调用基类的赋值运算符来完成的（即代码中baseDMAJ::operator(hs)）。



#### 总结

类设计回顾：

1. 默认构造函数：

   要么没有参数，要么所有的参数都是默认值。如果没有定义任何构造函数，编译器将定义默认构造函数。另外，如果派生类的构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分，在这种情况下如果基类没有构造函数（如果定义了某种构造函数，编译器将不会自动定义默认构造函数），则将导致编译阶段错误。

2. 复制构造函数：

   原型如下：

   ```c++
   Star(const Star &);
   ```

   在下述情况下，将使用复制构造函数：

   - 将新对象初始化为一个同类对象；
   - 按值将对象传递给函数；
   - 函数按值返回对象；
   - 编译器生成临时对象；

   默认的复制构造函数和赋值运算符都有一个浅复制的问题，因此一般需要定义自己的复制构造函数（深复制）

3. 赋值运算符

   默认赋值运算符用于处理同类对象之间的赋值。注意，不要把赋值和初始化弄混淆了，如果语句创建新对象时，则使用初始化；如果语句修改已有对象的值，则是赋值；

   基于与复制构造函数相同的原因，也需要显式的定义赋值运算符：

   ```c++
   Star & Star::operator=(const Star &){...}
   ```

   其中，编译器不会生成一种类型赋给另一种类型的赋值运算符，但是可以显式的定义。

#### 课后习题：复习题



##### 派生类从基类那里继承了什么？

基类的公有成员成为了派生类的公有成员，基类的保护成员成为了派生类的保护成员，基类的私有成员被继承，但不能直接访问。



##### 派生类不能从基类那里继承什么？

构造函数、析构函数、赋值运算符和友元。



##### 假设baseDMA::operator=()函数的返回类型为void，而不是baseDMA &，这将有什么后果？如果返回类型为baseDMA，而不是baseDMA &，又将有什么后果？

为void时仍可以进行单次赋值，但是不能进行连续赋值了。

若返回类型为对象而不是引用，执行速度（效率）将会降低。



##### 创建和删除派生类对象时，构造函数和析构函数调用的顺序是怎样的？

创建：先创建基类成员->再创建派生类成员

析构函数：先执行派生类的析构函数->再执行基类析构函数

（注意，箭头方向即派生链，创建是正序基->派生，而析构是派生->基类）



##### 如果派生类没有添加任何数据成员，它是否需要构造函数？

需要，每个类都必须有自己的构造函数，如果派生类没有添加新成员，则构造函数可以为空，但必须存在。



##### 如果基类和派生类定义了同名的方法，当派生类对象调用该方法时，被调用的将是哪个方法？

派生类的，同名方法会采用最近版本的，派生类没有定义时才会向上调用基类的。



#####  在什么情况下，派生类应定义赋值运算符？

如果派生类构造函数使用**new或者new[]**运算符来初始化类的指针成员，则应定义一个赋值运算符。更普通的说，如果对于派生类成员来说，默认赋值不正确，则应定义赋值运算符。



##### 可以将派生类对象的地址赋给基类指针吗？可以将基类对象的地址赋给派生类指针吗？

基类指针或者引用可以指向派生类对象的地址，反过来不行（除非定义了派生类转换为基类的转换函数）。



##### 可以将派生类对象赋给基类对象吗？可以将基类对象赋给派生类对象吗？

派生类可以赋给基类，因为派生类中包含了所有基类的成员，程序也将使用基类的赋值运算符；而基类不能赋给派生类，因为派生类中存在基类不存在的成员（除非显式定义了转换符，给派生类新增成员赋予初始值）



#####  假设定义了一个函数，它将基类对象的引用作为参数。为什么该函数也可以将派生类对象作为参数？

应为c++允许基类引用指向从该基类派生而来的任何类型。（反过来默认不允许）



##### 假设定义了一个函数，它将基类对象作为参数（即函数按值传递基类对象）。为什么该函数也可以将派生类对象作为参数？

按值传递的话首先会调用复制构造函数，形参是基类对象，因此将调用基类的复制构造函数，而复制构造函数的形参是基类引用，而根据上一题提到的，基类引用可以指向派生类对象，这里等于复制了派生类中的基类成员。所以这题的函数也可以将派生类对象作为参数。



##### 为什么通常按引用传递对象比按值传递对象的效率更高？

按引用传递对象，这样可以确保函数从虚函数受益。另外，按引用传递对象可以节省内存和时间，尤其对于大型对象。按值传递对象的主要有点在于可以保护原始数据，但可以通过将引用作为const类型传递，来达到同样的目的。



##### 假设Corporation是基类，PublicCorporation是派生类。再假设这两个类都定义了head()函数，ph是指向Corporation类型的指针，且被赋给了一个PublicCorporation对象的地址。如果基类将head( )定义为：

##### 	a. 常规非虚方法；

##### 	b. 虚方法；

**则ph->head()将被如何解释？**

a. ph是Corporation类型的指针，因此调用Corporation::head()

b. ph指向PublicCorporation对象，调用PublicCorporation::head()



##### 下述代码有什么问题？

```c++
class Kitchen
{
    private:
    double kit_sq_ft;
    public:
    Kitchen() { kit_sq_ft = 0.0; }
    virtual double area() const { return kit_sq_ft * kit_sq_ft; }
};
class House : public Kitchen
{
    private:
    double all_sq_ft;
    public: 
    House() { all_sq_ft += kit_sq_ft;}
    double area(const char *s) const { cout << s; return all_sq_ft; }
};

```

