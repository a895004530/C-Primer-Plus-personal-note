# 友元、异常和其他

#### 友元类

什么时候需要用到友元函数呢？举个例子：电视机和遥控器，假定需要编写一个模拟电视机和遥控器的简单程序，这两者很显然不符合is-a和has-a关系，这种时候就能用到友元，把遥控器类作为电视机类的一个友元类。

友元类的所有方法都可以访问原始类的私有成员和保护成员。

#### 友元成员函数

在书中的例子中，其实只有一个函数直接调用了原始类的私有成员，其他的函数实际上都是调用公有接口来实现的，因此我们其实可以通过使用友元成员函数而不是把整个类作为友元类。

```c++
class Tv
{
	friend void Remote::set_chan(Tv& t,int c);
}
```

然而，编译器并不知道Remote是一个类，因此直接使用会报错，我们需要在Tv类之前把Remote类声明了。但是，我们知道，remote类中大部分函数调用的是Tv类的公用接口，因此Tv类要在Remote类之前声明。相互依赖的关系该如何解决呢？解决方法如下

```
class Tv;//向前声明
class Remote{...};
class Tv{...};
```

只能以如上方式，不能把tv和remote对调，原因如下：在编译器看到TV类中存在一个方法被声明为TV类的友元函数之前，应该先看到Remote类和类中这个函数的声明。



#### 异常机制

下面介绍如何使用异常机制来处理错误。C++异常是对程序运行过程中发生的异常情况（例如被0除）的一种响应。异常提供了将控制权从程序的一部分传递到另一部分的途径。对异常的处理有 3 个组成部分：

- 引发异常；
- 使用处理程序捕获异常；
- 使用 try 块

虽然throw-catch机制类似于函数参数和函数返回机制，但不同的是，返回语句将控制权返回到调用fun（）的函数，而throw函数将语句控制权向上返回到第一个这样的函数（看看代码15.10和15.12的例子）

另外一个不同的是，引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。

既然throw语句生成副本，那代码中为什么还要用引用呢？答案是引用有一个重要特征：基类引用可以指向派生类对象。（见p630例子）

引发的异常对象将被第一个与之匹配的catch块捕获，这意味着catch块的排列顺序应该与派生类相反，即：

```c++
class bad_1{...}
class bad_2:public bad_1{...}
class bad_3:public bad_2{...}
...
void duper()
{
	...
	if(oh_no)
		throw bad_1();
	if (rat)
		throw bad_2();
	if(drat)
		throw bad_3();
}
try{
	duper();
}
catch(bad_3 & be){...}
catch(bad_2 & be){...}
catch(bad_1 & be){...}
```

如果是把bad_1放在最前面，那么这个catch bad_1将会捕获1,2,3的异常，因为基类引用可以指向派生类对象，因此1-3的三个对象都是符合参数的。



有时候并不知道被调用的函数可能引发哪些异常，在这种情况下仍能够捕获异常，即使不知道异常类型。方法是使用省略号表示异常类型，从而捕获任何异常：

```c++
catch(...){//statments}
```



#### RTTI

Runtime Type Identification 运行阶段类型识别

##### 用途：

假设有一个类层次结构，其中的类都是从一个基类派生而来的，即可以让基类指针指向任何一种类的对象。这样便可以调用这样的参数：在处理一些信息后，选择一个类，并创建这种类型的对象，然后返回它的地址，而该地址可以被赋给基类指针。如何知道指针指向的是哪种对象呢？



**RTTI元素一共有三个：**

- 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个派生类的指针，否则该运算符返回空指针；
- typeid运算符返回一个指出对象类型的值
- type_info结构存储了有关特定类型的信息

**dynamic_cast的使用方法：**

它是RTTI中最常用的组件，它不能回答“指针指向的哪类对象？”，但是它能回答“是否可以安全地将对象的地址赋给特定类型的指针”

```c++
class Grand { // has virtual methods };
class Superb : public Grand { ... };
class Magnificent : public Superb { ... };
//接下来假设有下面的指针：
Grand * pg = new Grand;
Grand * ps = new Superb;
Grand * pm = new Magnificent;
//最后，对于下面的类型转换：
Magnificent * p1 = (Magnificent * ) pm;		// #1
Magnificent * p2 = (Magnificent * ) pg;		// #2
Superb * p3 = (Magnificent *) pm;			// #3
```

哪些是安全的？根据类声明，它们**可能**全都是安全的，但只有那些指针类型与对象的类型（或对象的直接或间接基类的类型）相同的类型转换才一定是安全的。

例如，类型转换 #1 就是安全的，因为它将 Magnificent 类型的指针指向类型为 Magnificent 的对象。类型转换 #2 就是不安全的，因为它将基类对象 （Grand）的地址赋给派生类（Magnificent）指针。因此，程序将期望基类对象有派生类的特征，而通常这是不可能的。例如，Magnificent 对象可能包含一些 Grand 对象没有的数据成员。然而，类型转换 #3 是安全的，因为它将派生对象的地址赋给基类指针。即公有派生确保 Magnificent 对象同时也是一个 Superb 对象（直接基类）和一个 Grand 对象（间接基类）。因此，将它的地址赋给这 3 种类型的指针都是安全的。虚函数确保了将这 3 种指针中的任何一种指向 Magnificent 对象时，都将调用 Magnificent 方法。

先来看一下 dynamic_cast 的语法。该运算符的用法如下，其中 pg **指向一个对象**：

```c++
Superb * pm = dynamic_cast<Superb *> (pg)；
```

这提出了这样的问题：指针 pg 的类型是否可被安全地转换为 Superb *? 如果可以，运算符将返回**对象的地址**，然后通过等号赋给pm，否则返回一个空指针赋给pm。



#### typeid运算符和type_info类

typeid 运算符使得能够确定两个对象**是否为同种类型**。它与sizeof有些相像，可以接受两种参数：

- 类名；
- 结果为对象的表达式。

typeid 运算符返回一个对 type_info 对象的引用，其中，type_info 是在头文件 typeinfo（以前为 typeinfo.h）中定义的一个类。而type_info 类重载了 == 和 != 运算符，以便可以使用这些运算符来对类型进行比较。

```c++
typeid(Magnificent) == typeid(*pg)
```

例如，如果 pg 指向的是一个 Magnificent 对象，则下述表达式的结果为 bool 值 true，否则为 false。

如果 pg 是一个空指针，程序将引发 bad_typeid 异常。

